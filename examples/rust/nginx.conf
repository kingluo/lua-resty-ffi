daemon off;
error_log /dev/stderr info;
worker_processes auto;
env LD_LIBRARY_PATH;
env RUST_BACKTRACE=full;

events {}

http {
    init_worker_by_lua_block {
        cjson = require("cjson")
        grpc = require("grpc_client")

        grpc.loadfile("helloworld.proto")
        grpc.loadfile("route_guide.proto")
        grpc.loadfile("echo.proto")
    }

    server {
        listen 20000;

        location /gc {
            content_by_lua_block {
                collectgarbage()
                ngx.say("ok")
            }
        }

        location /echo {
            content_by_lua_block {
                local cfg = { name = "hello", value = "world", flag = 200 }
                local demo = ngx.load_ffi("echo", cjson.encode(cfg), {unpin = true})
                local ok, res = demo:echo("foobar")
                assert(ok)
                assert(res == "foobar")

                demo:__unload()
                ok, res = demo:echo("foobar")
                assert(not ok)
                ngx.log(ngx.ERR, res)

                ngx.say("ok")
            }
        }

        location /say_hello {
            content_by_lua_block {
                local ok, conn = grpc.connect("[::1]:50051")
                assert(ok)

                ngx.update_time()
                local t1 = ngx.now()
                for _ = 1,10000 do
                    local ok, res = conn:unary(
                        "/helloworld.Greeter/SayHello",
                        {name = "foobar"}
                    )
                    assert(ok)
                    assert(res.message == "Hello foobar!")
                end
                ngx.update_time()
                local t2 = ngx.now()
                ngx.say(t2-t1)

                conn:close()

                ngx.say("ok")
            }
        }

        location /tls {
            content_by_lua_block {
                local ok, conn = grpc.connect("[::1]:50051",
                    {
                        host = "example.com",
                        ca = grpc.readfile("/opt/tonic/examples/data/tls/ca.pem"),
                        cert = grpc.readfile("/opt/tonic/examples/data/tls/client1.pem"),
                        priv_key = grpc.readfile("/opt/tonic/examples/data/tls/client1.key"),
                    }
                )
                assert(ok)

                local ok, res = conn:unary(
                    "/grpc.examples.echo.Echo/UnaryEcho",
                    {message = "hello"}
                )
                assert(ok)
                assert(res.message == "hello")

                conn:close()

                ngx.say("ok")
            }
        }

        location /get_feature {
            content_by_lua_block {
                local ok, conn = grpc.connect("[::1]:10000")
                assert(ok)

                local ok, res = conn:unary(
                    "/routeguide.RouteGuide/GetFeature",
                    {latitude = 409146138, longitude = -746188906}
                )
                assert(ok)
                ngx.say(cjson.encode(res))

                ngx.say("ok")
            }
        }

        location /list_features {
            content_by_lua_block {
                local ok, conn = grpc.connect("[::1]:10000")
                assert(ok)

                -- A server-to-client streaming RPC.
                local ok, stream = conn:new_stream("/routeguide.RouteGuide/ListFeatures")
                assert(ok)

                local rectangle = {
                    lo = {latitude = 400000000, longitude = -750000000},
                    hi = {latitude = 420000000, longitude = -730000000},
                }
                local ok = stream:send(rectangle)
                assert(ok)

                local ok = stream:close_send()
                assert(ok)

                while true do
                    local ok, res = stream:recv()
                    assert(ok)
                    if not res then
                        break
                    end
                    ngx.say(cjson.encode(res))
                end

                ngx.say("ok")
            }
        }

        location /record_route {
            content_by_lua_block {
                local ok, conn = grpc.connect("[::1]:10000")
                assert(ok)

                -- A client-to-server streaming RPC.
                local ok, stream = conn:new_stream("/routeguide.RouteGuide/RecordRoute")
                assert(ok)

                for i=1,3 do
                    local point = {latitude = 409146138 + i*100, longitude = -746188906 + i*50}
                    local ok = stream:send(point)
                    assert(ok)
                end

                local ok = stream:close_send()
                assert(ok)

                local ok, res = stream:recv()
                assert(ok)
                ngx.say(cjson.encode(res))

                local ok, res = stream:recv()
                assert(ok and not res)

                local ok = stream:close()
                assert(ok)

                local ok = conn:close()
                assert(ok)

                ngx.say("ok")
            }
        }

        location /route_chat {
            content_by_lua_block {
                local ok, conn = grpc.connect("[::1]:10000")
                assert(ok)

                -- A Bidirectional streaming RPC.
                local ok, stream = conn:new_stream("/routeguide.RouteGuide/RouteChat")
                assert(ok)

                for i=1,3 do
                    local note = {
                        location = {latitude = 409146138 + i*100, longitude = -746188906 + i*50},
                        message = string.format("note-%d", i),
                    }
                    local ok = stream:send(note)
                    assert(ok)

                    local ok, res = stream:recv()
                    assert(ok)
                    ngx.say(cjson.encode(res))
                end

                local ok = stream:close()
                assert(ok)

                local ok = conn:close()
                assert(ok)

                ngx.say("ok")
            }
        }
    }
}
